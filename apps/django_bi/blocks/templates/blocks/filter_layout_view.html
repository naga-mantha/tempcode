{% extends "base.html" %}
{% load static %}
{% block content %}
<h2>{% if admin_mode %}Manage Default Filter Layout{% else %}Manage Filter Layout{% endif %} for {{ display_title|default:block.name|default:block_name }}</h2>

<div class="row">
  <div class="col-3">
    <h5>Available Fields</h5>
    <div id="available-fields" class="border rounded p-2" style="min-height: 200px;">
      <!-- populated by JS -->
    </div>
  </div>
  <div class="col-9">
    <div class="d-flex align-items-center justify-content-between">
      <h5 class="mb-0">Layout Builder</h5>
      <div>
        <button class="btn btn-sm btn-outline-primary" id="add-section" type="button">Add Section</button>
      </div>
    </div>
    <div id="builder" class="mt-2"></div>
  </div>
</div>

<form id="layout-form" method="post" action="{% url 'filter_layout_view' block_name %}" class="mt-3">
  {% csrf_token %}
  <input type="hidden" name="layout" id="layout-json-input" value="{}">
  <div class="d-flex gap-2">
    <button type="submit" name="action" value="save" class="btn btn-primary">Save</button>
    {% if not admin_mode %}
      <button type="submit" name="action" value="load_default" class="btn btn-outline-secondary">Load Admin Default</button>
    {% endif %}
  </div>
</form>

<script>
  const available = {{ available_fields|default:'[]'|safe }};
  const initialLayout = (function(){ try { return {{ layout_json|default:'{}'|safe }} || {}; } catch(e) { return {}; } })();

  function el(tag, attrs={}, ...children){
    const e = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v]) => {
      if (k === 'class') e.className = v; else if (k === 'dataset') Object.assign(e.dataset, v); else e.setAttribute(k, v);
    });
    children.forEach(c => { if (c == null) return; if (typeof c === 'string') e.appendChild(document.createTextNode(c)); else e.appendChild(c); });
    return e;
  }

  function buildEmptyLayout(){ return { sections: [] }; }
  function findToKey(fromKey){ const base = fromKey.endsWith('_from') ? fromKey.slice(0,-5) : null; if (!base) return null; const candidate = base + '_to'; return available.find(a=>a.key===candidate) ? candidate : null; }
  function addSection(layout, title){ layout.sections.push({title: title || '', cells: []}); }

  function renderAvailable(){
    const box = document.getElementById('available-fields');
    box.innerHTML = '';
    const list = el('div', {class:'list-group', id: 'available-fields-list'});
    available.forEach(f => {
      const item = el('div', {class:'list-group-item list-group-item-action py-1 px-2', 'data-key': f.key, 'data-type': f.type}, `${f.label} (${f.key})`);
      list.appendChild(item);
    });
    box.appendChild(list);
    if (window.Sortable){
      new Sortable(list, {
        group: { name: 'fields', pull: 'clone', put: false },
        sort: false,
        animation: 150,
        ghostClass: 'bg-warning-subtle',
      });
    }
  }

  function bindCellsSortable(listEl, secIndex){
    if (!window.Sortable) return;
    new Sortable(listEl, {
      group: { name: 'fields', pull: true, put: true },
      sort: true,
      animation: 150,
      ghostClass: 'bg-light',
      onAdd: function (evt){
        // Dropped from available list
        try {
          const fromEl = evt.item;
          const key = fromEl.getAttribute('data-key');
          if (!key) return;
          const cells = currentLayout.sections[secIndex].cells;
          const toKey = findToKey(key);
          if (toKey && confirm('Create a date range with "' + key + '" and "' + toKey + '"?')){
            cells.splice(evt.newIndex, 0, { range: [key, toKey], label: (available.find(a=>a.key===key)?.label || 'Date') + ' Between', cols: 12 });
          } else {
            cells.splice(evt.newIndex, 0, { key: key, cols: 12 });
          }
          renderBuilder(currentLayout);
          syncJson();
        } catch(e){}
      },
      onUpdate: function(evt){
        // Reorder within section cells
        const cells = currentLayout.sections[secIndex].cells;
        const newOrder = Array.from(listEl.querySelectorAll('[data-cell-idx]')).map(el => parseInt(el.getAttribute('data-cell-idx')));
        const reordered = newOrder.map(i => cells[i]);
        currentLayout.sections[secIndex].cells = reordered;
        renderBuilder(currentLayout);
        syncJson();
      },
      onRemove: function(){ syncJson(); }
    });
  }

  function renderBuilder(layout){
    const root = document.getElementById('builder');
    root.innerHTML = '';
    // no global options to set

    // Build sections container
    layout.sections.forEach((sec, si) => {
      const secWrap = el('div', {class:'border rounded p-3 mb-5 section-wrap bg-light', 'data-sec-idx': String(si)});
      const titleInput = el('input', {class:'form-control form-control-sm me-2', value: sec.title || ''});
      titleInput.addEventListener('input', (e)=>{ sec.title = e.target.value; syncJson(); });
      const removeSecBtn = el('button', {class:'btn btn-sm btn-outline-danger', type:'button'}, 'Remove Section');
      removeSecBtn.addEventListener('click', ()=>{ layout.sections.splice(si,1); renderBuilder(layout); syncJson(); });
      const header = el('div', {class:'d-flex align-items-center justify-content-between mb-2'},
        el('div', {class:'flex-grow-1 me-2'}, titleInput),
        el('div', {}, removeSecBtn)
      );
      secWrap.appendChild(header);

      // Render cells in a single droppable list (auto-wrap on save)
      const cellsContainer = el('div', {class:'row g-2 align-items-start mb-2 border-top pt-2', id:`cells-${si}`});
      const cells = sec.cells || [];
      cells.forEach((cell, ci) => {
          const cols = Math.min(Math.max(parseInt(cell.cols||12) || 12,1),12);
          const colEl = el('div', {class:'col-'+cols, 'data-cell-idx': String(ci)});
          const card = el('div', {class:'p-2 border rounded bg-white'});
          const top = el('div', {class:'d-flex justify-content-between align-items-center mb-1'});
          const title = cell.key ? (available.find(a=>a.key===cell.key)?.label || cell.key) : (cell.label || 'Range');
          top.appendChild(el('strong', {}, title));
          const controls = el('div', {});
          const widthSel = el('select', {class:'form-select form-select-sm me-2'});
          [12,6,4,3].forEach(n => { const opt = el('option', {value:String(n)}, String(n)); if (n===cols) opt.selected = true; widthSel.appendChild(opt); });
          widthSel.addEventListener('change', (e)=>{ cell.cols = parseInt(e.target.value); renderBuilder(layout); syncJson(); });
          const removeBtn = el('button', {class:'btn btn-sm btn-outline-danger', type:'button'}, 'Remove');
          removeBtn.addEventListener('click', ()=>{ cells.splice(ci,1); renderBuilder(layout); syncJson(); });
          controls.appendChild(widthSel);
          controls.appendChild(removeBtn);
          top.appendChild(controls);
          card.appendChild(top);
          if (cell.range){
            const lbl = el('input', {class:'form-control form-control-sm', value: cell.label || '', placeholder:'Label (optional)'});
            lbl.addEventListener('input', (e)=>{ cell.label = e.target.value; syncJson(); });
            card.appendChild(lbl);
            card.appendChild(el('div', {class:'form-text'}, `${cell.range[0]} .. ${cell.range[1]}`));
          } else {
            card.appendChild(el('div', {class:'form-text'}, `${cell.key}`));
          }
          colEl.appendChild(card);
          cellsContainer.appendChild(colEl);
      });
      bindCellsSortable(cellsContainer, si);
      secWrap.appendChild(cellsContainer);

      root.appendChild(secWrap);
    });

    // Make sections draggable
    if (window.Sortable){
      new Sortable(root, {
        handle: '.section-wrap',
        draggable: '.section-wrap',
        animation: 150,
        onEnd: function(){
          const order = Array.from(root.querySelectorAll('.section-wrap')).map(el => parseInt(el.getAttribute('data-sec-idx')));
          const reordered = order.map(i => currentLayout.sections[i]);
          currentLayout.sections = reordered;
          renderBuilder(currentLayout);
          syncJson();
        }
      });
    }
  }

  function packRows(cells){
    const rows = [];
    let cur = [];
    let acc = 0;
    cells.forEach(cell => {
      const w = Math.min(Math.max(parseInt(cell.cols||12) || 12,1),12);
      if (acc + w > 12 && cur.length){ rows.push(cur); cur = []; acc = 0; }
      cur.push(cell); acc += w;
    });
    if (cur.length) rows.push(cur);
    return rows;
  }

  function syncJson(){
    const out = { sections: [] };
    currentLayout.sections.forEach(sec => {
      const cells = (sec.cells || []).map(c => ({...c}));
      out.sections.push({ title: sec.title || '', rows: packRows(cells) });
    });
    document.getElementById('layout-json-input').value = JSON.stringify(out);
  }

  const currentLayout = (function(){
    // Convert initial rows-based layout to cells-based builder state
    const src = (initialLayout && typeof initialLayout === 'object') ? initialLayout : buildEmptyLayout();
    const out = { sections: [] };
    (src.sections || []).forEach(sec => {
      const cells = [];
      (sec.rows || []).forEach(row => { (row || []).forEach(cell => cells.push(cell)); });
      out.sections.push({ title: sec.title || '', cells });
    });
    if (!out.sections.length) out.sections.push({ title: '', cells: [] });
    return out;
  })();

  document.getElementById('add-section').addEventListener('click', function(){ addSection(currentLayout, ''); renderBuilder(currentLayout); syncJson(); });
  // no extra global option listeners

  renderAvailable();
  renderBuilder(currentLayout);
  syncJson();
</script>
<style>
  /* Make sections easier to grab and visually distinct */
  .section-wrap { cursor: move; background-color: #f8f9fa; }
  .section-wrap .row.g-2 { background: #ffffff; border-radius: .25rem; padding: .5rem; }
  #available-fields { min-height: 260px; }
  #builder .list-group-item { cursor: grab; }
  .sortable-ghost { opacity: .7; }
</style>
{% endblock %}
