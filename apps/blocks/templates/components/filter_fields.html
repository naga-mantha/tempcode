<!--{# expects:-->
<!--   - filter_schema: dict of key -> {label, type, help?, choices?, multiple?, tom_select_options?}-->
<!--   - initial_values: dict of key -> value (or list for multiselect)-->
<!--#}-->
{% load dict_extras static %}

{% for key, cfg in filter_schema.items %}
  {% with val=initial_values|get_item:key %}
  {# Skip rendering standalone '_to' date inputs when a paired '_from' exists; they'll be rendered together below #}
  {% with key_tail=key|slice:"-3:" from_key=key|slice:":-3"|add:"_from" %}
  {% if cfg.type == 'date' and key_tail == '_to' and filter_schema|get_item:from_key %}
    {# paired _to will be rendered together with its _from; skip #}
  {% else %}
  <div class="mb-4 filter-field">
    {# Group date ranges: render '<Base Label> Between' with two date inputs when *_from and *_to exist #}
    {% if cfg.type == 'date' and key|slice:'-5:' == '_from' %}
      {% with base_key=key|slice:':-5' %}
      {% with to_key=base_key|add:'_to' %}
      {% with to_val=initial_values|get_item:to_key %}
      {% if filter_schema|get_item:to_key %}
      <label class="form-label">{{ cfg.label|cut:" From" }} Between</label>
      <div class="d-flex gap-3 align-items-start flex-wrap">
        <div class="date-filter-wrapper" data-key="{{ key }}">
          <div class="d-flex gap-2 align-items-start flex-wrap">
            <input type="text" class="form-control date-token-input" style="min-width: 220px;"
                   name="{{ name_prefix|default:'filters.' }}{{ key }}"
                   value="{{ val|default:'' }}"
                   placeholder="YYYY-MM-DD or token"/>
            <div>
              <button class="btn btn-outline-secondary btn-sm pick-date-btn" type="button">Pick Date</button>
              <input type="date" class="date-picker" style="position:absolute;opacity:0;width:0;height:0;pointer-events:none;" tabindex="-1" aria-hidden="true"/>
            </div>
            <select class="form-select form-select-sm date-quick-select" style="min-width: 200px;">
              <option value="">Quick pick…</option>
              <option value="__today__">Today</option>
              <option value="__start_of_month__">Start of Month</option>
              <option value="__end_of_month__">End of Month</option>
              <option value="__start_of_quarter__">Start of Quarter</option>
              <option value="__end_of_quarter__">End of Quarter</option>
              <option value="__start_of_year__">Start of Year</option>
              <option value="__end_of_year__">End of Year</option>
              <option value="__current_fiscal_year_start__">Current FY Start</option>
              <option value="__current_fiscal_year_end__">Current FY End</option>
            </select>
          </div>
        </div>
        <div class="date-filter-wrapper" data-key="{{ to_key }}">
          <div class="d-flex gap-2 align-items-start flex-wrap">
            <input type="text" class="form-control date-token-input" style="min-width: 220px;"
                   name="{{ name_prefix|default:'filters.' }}{{ to_key }}"
                   value="{{ to_val|default:'' }}"
                   placeholder="YYYY-MM-DD or token"/>
            <div>
              <button class="btn btn-outline-secondary btn-sm pick-date-btn" type="button">Pick Date</button>
              <input type="date" class="date-picker" style="position:absolute;opacity:0;width:0;height:0;pointer-events:none;" tabindex="-1" aria-hidden="true"/>
            </div>
            <select class="form-select form-select-sm date-quick-select" style="min-width: 200px;">
              <option value="">Quick pick…</option>
              <option value="__today__">Today</option>
              <option value="__start_of_month__">Start of Month</option>
              <option value="__end_of_month__">End of Month</option>
              <option value="__start_of_quarter__">Start of Quarter</option>
              <option value="__end_of_quarter__">End of Quarter</option>
              <option value="__start_of_year__">Start of Year</option>
              <option value="__end_of_year__">End of Year</option>
              <option value="__current_fiscal_year_start__">Current FY Start</option>
              <option value="__current_fiscal_year_end__">Current FY End</option>
            </select>
          </div>
        </div>
      </div>
      {% else %}
      {# Fallback: only _from exists; render single date field #}
      <label class="form-label">{{ cfg.label }}</label>
      <div class="date-filter-wrapper" data-key="{{ key }}">
        <div class="d-flex gap-2 align-items-start flex-wrap">
          <input type="text" class="form-control date-token-input" style="min-width: 220px;"
                 name="{{ name_prefix|default:'filters.' }}{{ key }}"
                 value="{{ val|default:'' }}"
                 placeholder="YYYY-MM-DD or token"/>
          <div>
            <button class="btn btn-outline-secondary btn-sm pick-date-btn" type="button">Pick Date</button>
            <input type="date" class="date-picker" style="position:absolute;opacity:0;width:0;height:0;pointer-events:none;" tabindex="-1" aria-hidden="true"/>
          </div>
          <select class="form-select form-select-sm date-quick-select" style="min-width: 200px;">
            <option value="">Quick pick…</option>
            <option value="__today__">Today</option>
            <option value="__start_of_month__">Start of Month</option>
            <option value="__end_of_month__">End of Month</option>
            <option value="__start_of_quarter__">Start of Quarter</option>
            <option value="__end_of_quarter__">End of Quarter</option>
            <option value="__start_of_year__">Start of Year</option>
            <option value="__end_of_year__">End of Year</option>
            <option value="__current_fiscal_year_start__">Current FY Start</option>
            <option value="__current_fiscal_year_end__">Current FY End</option>
          </select>
        </div>
      </div>
      {% endif %}
      {% endwith %}
      {% endwith %}
      {% endwith %}

    {% elif cfg.type == 'select' %}
      <label class="form-label">{{ cfg.label }}</label>
      <select class="form-select filter-field-select" name="{{ name_prefix|default:'filters.' }}{{ key }}"{% if cfg.choices_url %} data-ajax-url="{{ cfg.choices_url }}"{% endif %}{% if cfg.tom_select_options %} data-tom-select-options='{{ cfg.tom_select_options|tojson }}'{% endif %}>
        <option value="">-- Any --</option>
        {% if not cfg.choices_url %}
          {% for v, lbl in cfg.choices %}
            <option value="{{ v }}" {% if val|stringformat:"s" == v|stringformat:"s" %}selected{% endif %}>
              {{ lbl }}
            </option>
          {% endfor %}
        {% elif val %}
          {# for AJAX selects, include current value so Tom Select can display it #}
          <option value="{{ val }}" selected>{{ val }}</option>
        {% endif %}
      </select>

    {% elif cfg.type == 'multiselect' %}
      <label class="form-label">{{ cfg.label }}</label>
      <select class="form-select filter-field-select" name="{{ name_prefix|default:'filters.' }}{{ key }}" multiple{% if cfg.choices_url %} data-ajax-url="{{ cfg.choices_url }}"{% endif %}{% if cfg.tom_select_options %} data-tom-select-options='{{ cfg.tom_select_options|tojson }}'{% endif %}>
        {% if not cfg.choices_url %}
          {% for v, lbl in cfg.choices %}
            <option value="{{ v }}" {% if val and v in val %}selected{% endif %}>
              {{ lbl }}
            </option>
          {% endfor %}
        {% elif val %}
          {% for v in val %}
            <option value="{{ v }}" selected>{{ v }}</option>
          {% endfor %}
        {% else %}
          <option value=""></option>
        {% endif %}
      </select>
      <div class="form-text">Hold Ctrl/Cmd to select multiple.</div>

    {% elif cfg.type == 'number' %}
      <label class="form-label">{{ cfg.label }}</label>
      <input type="number" class="form-control" name="{{ name_prefix|default:'filters.' }}{{ key }}" value="{{ val|default:'' }}"/>

    {% elif cfg.type == 'date' %}
      <label class="form-label">{{ cfg.label }}</label>
      <div class="date-filter-wrapper" data-key="{{ key }}">
        <div class="d-flex gap-2 align-items-start flex-wrap">
          <input type="text" class="form-control date-token-input" style="min-width: 220px;"
                 name="{{ name_prefix|default:'filters.' }}{{ key }}"
                 value="{{ val|default:'' }}"
                 placeholder="YYYY-MM-DD or token"/>
          <div>
            <button class="btn btn-outline-secondary btn-sm pick-date-btn" type="button">Pick Date</button>
            <input type="date" class="date-picker" style="position:absolute;opacity:0;width:0;height:0;pointer-events:none;" tabindex="-1" aria-hidden="true"/>
          </div>
          <select class="form-select form-select-sm date-quick-select" style="min-width: 200px;">
            <option value="">Quick pick…</option>
            <option value="__today__">Today</option>
            <option value="__start_of_month__">Start of Month</option>
            <option value="__end_of_month__">End of Month</option>
            <option value="__start_of_quarter__">Start of Quarter</option>
            <option value="__end_of_quarter__">End of Quarter</option>
            <option value="__start_of_year__">Start of Year</option>
            <option value="__end_of_year__">End of Year</option>
            <option value="__current_fiscal_year_start__">Current FY Start</option>
            <option value="__current_fiscal_year_end__">Current FY End</option>
          </select>
        </div>
      </div>

    {% elif cfg.type == 'boolean' %}
      <label class="form-label">{{ cfg.label }}</label>
      <div class="form-check">
        <input type="checkbox" class="form-check-input" id="{{ id_prefix|default:'' }}-filters_{{ key }}"
               name="{{ name_prefix|default:'filters.' }}{{ key }}" value="1" {% if val %}checked{% endif %}>
        <label class="form-check-label" for="{{ id_prefix|default:'' }}-filters_{{ key }}">Yes</label>
      </div>

    {% else %}
      <label class="form-label">{{ cfg.label }}</label>
      {# default to text #}
      <input type="text" class="form-control" name="{{ name_prefix|default:'filters.' }}{{ key }}" value="{{ val|default:'' }}"/>
    {% endif %}

    {% if cfg.help %}
      <div class="form-text">{{ cfg.help }}</div>
    {% endif %}
  </div>
  {% endif %}
  {% endwith %}
  {% endwith %}
{% endfor %}

<script>
  // Initialize Tom Select only on actual <select> elements and guard parsing.
  document.querySelectorAll('select.filter-field-select').forEach(function(el){
    try {
      if (!el || el.tagName !== 'SELECT') return;
      if (el.dataset.tomInitialized) return;
      el.dataset.tomInitialized = '1';

      const ajaxUrl = el.dataset.ajaxUrl;
      const settings = { persist: false, maxOptions: 200 };

      if (el.multiple) {
        settings.plugins = ['remove_button'];
      }

      if (ajaxUrl) {
        settings.valueField = 'value';
        settings.labelField = 'label';
        settings.searchField = 'label';
        // Let Tom Select manage remote loads on focus and typing
        settings.preload = 'focus';
        settings.shouldLoad = function(query){ return true; };
        settings.load = function(query, callback){
          try {
            const url = buildUrl(ajaxUrl, query);
            fetch(url).then(r => r.ok ? r.json() : []).then(callback).catch(() => callback());
          } catch(e) { callback(); }
        };
      }

      let extraOpts = {};
      if (el.dataset.tomSelectOptions) {
        try { extraOpts = JSON.parse(el.dataset.tomSelectOptions) || {}; } catch (e) { extraOpts = {}; }
      }

      const ts = new TomSelect(el, { ...settings, ...extraOpts });
      if (ts && typeof ts.setTextboxValue === 'function') {
        ts.on('item_add', () => ts.setTextboxValue(''));
      }

      // Helper to build URL with current filters for this form
      function buildUrl(base, queryStr='', selectedOnly=false){
        const form = el.closest('form') || document;
        const params = new URLSearchParams();
        // include current filters.* values from all selects in the same form
        const sels = form.querySelectorAll('select.filter-field-select');
        sels.forEach(s => {
          const nameAttr = s.getAttribute('name') || '';
          let paramName = null;
          if (nameAttr.startsWith('filters.')) {
            paramName = nameAttr;
          } else {
            const idx = nameAttr.indexOf('__filters.');
            if (idx !== -1) {
              paramName = 'filters.' + nameAttr.slice(idx + '__filters.'.length);
            }
          }
          if (!paramName) return;
          const isMulti = s.hasAttribute('multiple');
          const values = isMulti ? (Array.from(s.selectedOptions).map(o => o.value).filter(Boolean)) : [s.value].filter(Boolean);
          values.forEach(v => params.append(paramName, v));
        });
        // include query from Tom Select typing, or from provided argument
        const txt = (queryStr || (ts && ts.getTextboxValue ? (ts.getTextboxValue() || '').trim() : '')).trim();
        if (!selectedOnly && txt) params.set('q', txt);
        const hasParams = Array.from(params.keys()).length > 0;
        return base + (hasParams ? ('?' + params.toString()) : '');
      }

      // Fetch and replace options; auto-clear invalid selections
      async function reloadOptions(){
        if (!ajaxUrl) return false;
        const url = buildUrl(ajaxUrl);
        try {
          const res = await fetch(url);
          if (!res.ok) return false;
          const list = await res.json();
          const allowed = new Set((list || []).map(x => String(x.value)));
          // Clear options then add new ones
          ts.clearOptions();
          (list || []).forEach(opt => { try { ts.addOption(opt); } catch(e){} });
          ts.refreshOptions(false);
          // Auto-clear selected values that are no longer valid
          const sel = Array.isArray(ts.items) ? ts.items.slice() : [];
          let changed = false;
          sel.forEach(v => { if (!allowed.has(String(v))) { try { ts.removeItem(v, true); changed = true; } catch(e){} } });
          if (changed) ts.refreshItems();
          return true;
        } catch(e) { /* ignore */ return false; }
      }

      // If there are preselected values and this is an AJAX select,
      // fetch their labels explicitly so the control shows code+name (not raw IDs).
      if (ajaxUrl) {
        const selectedValues = Array.from(el.options).filter(o => o.selected && o.value !== '').map(o => o.value);
        if (selectedValues.length > 0) {
          const url = ajaxUrl + '?ids=' + encodeURIComponent(selectedValues.join(','));
          fetch(url)
            .then(r => r.ok ? r.json() : [])
            .then(list => {
              if (!list || !Array.isArray(list)) return;
              list.forEach(opt => {
                try {
                  ts.addOption(opt);
                  ts.updateOption(opt.value, opt);
                } catch (e) { /* ignore */ }
              });
              // Re-add selected items to ensure labels refresh
              selectedValues.forEach(v => { try { ts.addItem(v, true); } catch (e) {} });
            })
            .catch(() => {});
        }

        // Ensure one fetch on initial focus to populate
        ts.on('focus', () => {
          reloadOptions().then(() => { try { if (!ts.dropdown.isOpen) ts.open(); } catch(e){} });
        });
        ts.on('dropdown_open', () => { reloadOptions(); });
      }
    } catch (e) {
      // Fail-safe: do not block page if a single field fails to initialize
      // console.warn('TomSelect init failed', e);
    }
  });

  // When any filter changes, refresh sibling AJAX selects and auto-clear invalids
  document.addEventListener('change', function(e){
    const target = e.target;
    if (!target || !(target.matches && target.matches('select.filter-field-select'))) return;
    const container = (target.closest('form')) || document;
    const sels = container.querySelectorAll('select.filter-field-select');
    sels.forEach(sel => {
      if (sel === target) return; // refresh siblings only
      if (!sel.dataset.ajaxUrl) return;
      const ts = sel.tomselect;
      if (!ts) return;
      // Trigger a reload using current filters
      try {
        // Inline helper mirroring reloadOptions above
        const ajaxUrl = sel.dataset.ajaxUrl;
        const params = new URLSearchParams();
        container.querySelectorAll('select.filter-field-select').forEach(s => {
          const nameAttr = s.getAttribute('name') || '';
          let paramName = null;
          if (nameAttr.startsWith('filters.')) {
            paramName = nameAttr;
          } else {
            const idx = nameAttr.indexOf('__filters.');
            if (idx !== -1) {
              paramName = 'filters.' + nameAttr.slice(idx + '__filters.'.length);
            }
          }
          if (!paramName) return;
          const isMulti = s.hasAttribute('multiple');
          const values = isMulti ? (Array.from(s.selectedOptions).map(o => o.value).filter(Boolean)) : [s.value].filter(Boolean);
          values.forEach(v => params.append(paramName, v));
        });
        const url = ajaxUrl + (Array.from(params.keys()).length ? ('?' + params.toString()) : '');
        fetch(url).then(r => r.ok ? r.json() : []).then(list => {
          const allowed = new Set((list || []).map(x => String(x.value)));
          ts.clearOptions();
          (list || []).forEach(opt => { try { ts.addOption(opt); } catch(e){} });
          ts.refreshOptions(false);
          const selItems = Array.isArray(ts.items) ? ts.items.slice() : [];
          let changed = false;
          selItems.forEach(v => { if (!allowed.has(String(v))) { try { ts.removeItem(v, true); changed = true; } catch(e){} } });
          if (changed) ts.refreshItems();
        }).catch(() => {});
      } catch(e) { /* ignore */ }
    });
  });

  // Wire up date pickers + quick tokens to the date text input
  document.querySelectorAll('.date-filter-wrapper').forEach(function(wrap){
    try {
      const textInput = wrap.querySelector('.date-token-input');
      const hiddenPicker = wrap.querySelector('.date-picker');
      const pickBtn = wrap.querySelector('.pick-date-btn');
      const quickSel = wrap.querySelector('.date-quick-select');
      pickBtn?.addEventListener('click', function(){ hiddenPicker?.showPicker ? hiddenPicker.showPicker() : hiddenPicker?.click(); });
      hiddenPicker?.addEventListener('change', function(){ if (textInput) textInput.value = hiddenPicker.value || ''; });
      quickSel?.addEventListener('change', function(){ if (quickSel.value && textInput) { textInput.value = quickSel.value; } });
    } catch(e) {}
  });
</script>
<style>
  /* Ensure consistent spacing under each filter field */
  .filter-field { margin-bottom: 1rem; }
  /* In case of tight containers, enforce bottom spacing */
  .filter-field:last-child { margin-bottom: 1rem; }
  /* Compact spacing for inline controls within date fields */
  .date-filter-wrapper .form-text { margin-top: 0.25rem; }
  .date-filter-wrapper .btn.pick-date-btn { white-space: nowrap; }
</style>
