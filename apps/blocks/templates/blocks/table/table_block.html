{% load static %}
<div class="js-layout-block-root" id="layout-block-{{ instance_id }}" data-instance-id="{{ instance_id }}" data-block-name="{{ block_name }}">
{# SheetJS + jsPDF only when not embedded inside a layout to avoid duplicate script injections #}
{% if not embedded %}
  <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>
{% endif %}

<div class="d-flex justify-content-between align-items-center mb-3">
  <div>
    <label class="me-2">View:</label>
    <select id="column-config-select-{{ block_name }}-{{ instance_id }}" class="form-select d-inline-block w-auto me-2">
      {% for cfg in column_configs %}
        <option value="{{ cfg.id }}" {% if cfg.id == active_column_config_id %}selected{% endif %}>
          {{ cfg.name }}
        </option>
      {% endfor %}
    </select>
    <a class="btn btn-link p-0" href="{% url 'column_config_view' block_name %}">Manage Views</a>
    <a class="btn btn-link p-0 ms-2" href="{% url 'render_table_block' block_name %}">Table Link</a>
  </div>
  <div>
    <label class="me-2">Filter:</label>
    <select id="filter-config-select-{{ block_name }}-{{ instance_id }}" class="form-select d-inline-block w-auto">
      <option value="">-- None --</option>
      {% for f in filter_configs %}
        <option value="{{ f.id }}" {% if f.id == active_filter_config_id %}selected{% endif %}>
          {{ f.name }}{% if f.is_default %} (default){% endif %}
        </option>
      {% endfor %}
    </select>
    <a class="btn btn-link p-0 ms-2" href="{% url 'table_filter_config' block_name %}">Manage Filters</a>
    <button id="download-xlsx-{{ block_name }}-{{ instance_id }}" class="btn btn-outline-secondary btn-sm ms-3" type="button" title="Download as Excel">
      Download Excel
    </button>
    <button id="download-pdf-{{ block_name }}-{{ instance_id }}" class="btn btn-outline-secondary btn-sm ms-2" type="button" title="Download as PDF">
      Download PDF
    </button>
  </div>

</div>

{# Live (non-persistent) filter fields; pre-populated from selected saved filter #}
<form method="get" id="dynamic-filters-form-{{ block_name }}-{{ instance_id }}" class="mb-3">
  {# preserve current selections when applying live overrides #}
  {% if active_column_config_id %}
    <input type="hidden" name="{{ block_name }}__{{ instance_id }}__column_config_id" value="{{ active_column_config_id }}">
  {% endif %}
  {% if active_filter_config_id %}
    <input type="hidden" name="{{ block_name }}__{{ instance_id }}__filter_config_id" value="{{ active_filter_config_id }}">
  {% endif %}

  <details class="border rounded">
    <summary class="p-2 bg-light" style="cursor:pointer;font-weight:bold">
      Filter Conditions
    </summary>
    <div class="p-3">
      <div class="mb-2">
        <a class="btn btn-link p-0" href="{% url 'filter_layout_view' block_name %}">Manage Filter Layout</a>
        {% if request.user.is_staff %}
          <a class="btn btn-link p-0 ms-3" href="{% url 'admin_filter_layout_view' block_name %}">Manage Default Filter Layout</a>
        {% endif %}
      </div>
      {# Renders actual inputs based on your schema #}
      {% include "components/filter_fields.html" with filter_schema=filter_schema initial_values=selected_filter_values filter_layout=filter_layout name_prefix=block_name|add:"__"|add:instance_id|add:"__filters." id_prefix=block_name|add:"-"|add:instance_id require_layout=True %}
      <button type="submit" class="btn btn-primary mt-2">Apply Filters</button>
    </div>
  </details>
</form>

{# Layout-embedded title/notes just below Filter Conditions #}
{% if request.GET.embedded_title or request.GET.embedded_note or request.GET.embedded_edit %}
  <div class="mb-2">
    {% if request.GET.embedded_edit %}
      <div class="row g-2">
        <div class="col-12 col-md-6">
          <label class="form-label mb-1 small">Title (optional)</label>
          <input type="text" class="form-control form-control-sm js-block-title" data-id="{{ instance_id }}" value="{{ request.GET.embedded_title }}" placeholder="Enter a title for this block">
        </div>
        <div class="col-12">
          <label class="form-label mb-1 small">Notes (optional)</label>
          <textarea class="form-control form-control-sm js-block-notes" data-id="{{ instance_id }}" rows="2" placeholder="Enter notes for this block">{{ request.GET.embedded_note }}</textarea>
        </div>
      </div>
    {% else %}
      {% if request.GET.embedded_title %}<div class="fw-bold">{{ request.GET.embedded_title }}</div>{% endif %}
      {% if request.GET.embedded_note %}<div class="text-muted small">{{ request.GET.embedded_note|linebreaksbr }}</div>{% endif %}
    {% endif %}
  </div>
{% endif %}

<div id="table-{{ block_name }}-{{ instance_id }}"></div>

{% block scripts %}
<script>
  (function init(){
    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init, { once: true }); return; }
    {% if request.GET.embedded %}const IS_EMBEDDED = true;{% else %}const IS_EMBEDDED = false;{% endif %}
    // 1) Initialize the table
    const tableEl = document.getElementById("table-{{ block_name }}-{{ instance_id }}");
    // adjust columns to enforce per-row editability using __editable flags
    const baseColumns = {{ columns|safe }};
    const columns = baseColumns.map(col => {
      if (col.editor) {
        col.editable = function(cell){
          const data = cell.getRow().getData();
          const f = cell.getColumn().getField();
          return data && data.__editable && data.__editable[f] === true;
        };
      }
      // Add header filter to every column
      if (!col.headerFilter) {
        col.headerFilter = "input";
        col.headerFilterLiveFilter = true;
      }
      return col;
    });

    const table = new Tabulator(tableEl, {
      layout: "fitColumns",
      data:{{ data|safe }},
      columns:columns,
      ...{{ tabulator_options|safe }},  // ensure trailing comma
    });

    // Ensure Tabulator sees jsPDF global when using the UMD build
    try {
      if (window.jspdf && window.jspdf.jsPDF && !window.jsPDF) {
        window.jsPDF = window.jspdf.jsPDF;
      }
    } catch (e) {}

    // 3) Inline editing: send changes to server
    table.on("cellEdited", function(cell){
      const row = cell.getRow();
      const id = row.getData().id;
      const field = cell.getField();
      const value = cell.getValue();
      if (id == null) { return; }
      fetch("{% url 'inline_edit' block_name %}", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({id, field, value}),
      }).then(res => res.json()).then(resp => {
        if (!resp.success) {
          alert(resp.error || "Update failed");
          cell.restoreOldValue();
        }
      }).catch(() => {
        alert("Network error while saving");
        cell.restoreOldValue();
      });
    });

    // helper to preserve both column_config_id and filter_config_id in URL
    function setSearchParams(params) {
      const url = new URL(window.location.href);
      Object.entries(params).forEach(([k, v]) => {
        if (v === "" || v === null || v === undefined) url.searchParams.delete(k);
        else url.searchParams.set(k, v);
      });
      window.location.href = url.toString();
    }
    function clearNamespacedFilters(urlObj){
      const nsPrefix = "{{ block_name }}__{{ instance_id }}__filters.";
      const toDelete = [];
      for (const [k] of urlObj.searchParams.entries()){
        if (k.startsWith(nsPrefix)) toDelete.push(k);
      }
      toDelete.forEach(k => urlObj.searchParams.delete(k));
    }

    // 2) Keep both selections when switching either dropdown
    const colSelect = document.getElementById("column-config-select-{{ block_name }}-{{ instance_id }}");
    const filtSelect = document.getElementById("filter-config-select-{{ block_name }}-{{ instance_id }}");
    colSelect?.addEventListener("change", function() {
      const url = new URL(window.location.href);
      const colKey = "{{ block_name }}__{{ instance_id }}__column_config_id";
      const filterKey = "{{ block_name }}__{{ instance_id }}__filter_config_id";
      const filterId = (filtSelect?.value || url.searchParams.get(filterKey) || "");
      if (this.value) url.searchParams.set(colKey, this.value); else url.searchParams.delete(colKey);
      if (filterId) url.searchParams.set(filterKey, filterId); else url.searchParams.delete(filterKey);
      if (IS_EMBEDDED && typeof window.updateLayoutBlock === 'function') {
        history.replaceState(null, '', url.toString());
        window.updateLayoutBlock("{{ instance_id }}");
      } else {
        window.location.href = url.toString();
      }
    });

    filtSelect?.addEventListener("change", function() {
      const url = new URL(window.location.href);
      // Clear any ad-hoc filter overrides so saved config values show
      clearNamespacedFilters(url);
      const columnKey = "{{ block_name }}__{{ instance_id }}__column_config_id";
      const filterKey = "{{ block_name }}__{{ instance_id }}__filter_config_id";
      const columnId = colSelect?.value || url.searchParams.get(columnKey) || "";
      if (columnId) url.searchParams.set(columnKey, columnId); else url.searchParams.delete(columnKey);
      if (this.value) url.searchParams.set(filterKey, this.value); else url.searchParams.delete(filterKey);
      if (IS_EMBEDDED && typeof window.updateLayoutBlock === 'function') {
        history.replaceState(null, '', url.toString());
        window.updateLayoutBlock("{{ instance_id }}");
      } else {
        window.location.href = url.toString();
      }
    });

    // 3) Intercept live filter form submit when embedded to do partial refresh
    const form = document.getElementById('dynamic-filters-form-{{ block_name }}-{{ instance_id }}');
    form?.addEventListener('submit', function(e){
      if (!IS_EMBEDDED || typeof window.updateLayoutBlock !== 'function') return;
      e.preventDefault();
      const url = new URL(window.location.href);
      // Remove existing namespaced filters for this block, then set from form
      clearNamespacedFilters(url);
      const fd = new FormData(form);
      for (const [k, v] of fd.entries()){
        if (!k) continue;
        if (v === null || v === undefined) continue;
        if (String(v).length === 0) continue;
        url.searchParams.set(k, String(v));
      }
      history.replaceState(null, '', url.toString());
      window.updateLayoutBlock("{{ instance_id }}");
    });

    // 4) Download to XLSX using Tabulator + SheetJS, configured per block
    const dlBtn = document.getElementById("download-xlsx-{{ block_name }}-{{ instance_id }}");
    dlBtn?.addEventListener("click", function(){
      try {
        const xlsxCfg = {{ xlsx_download|default:"{}"|safe }} || {};
        const filename = (xlsxCfg.filename && String(xlsxCfg.filename).trim()) || ("{{ block_name }}" + ".xlsx");
        const sheetName = (xlsxCfg.sheetName && String(xlsxCfg.sheetName).trim()) || ("{{ block_name }}" || "Data");

        // optional header styling via SheetJS (best-effort; ignored if not supported)
        let documentProcessing;
        if (xlsxCfg.header && typeof XLSX !== 'undefined') {
          const headerCfg = xlsxCfg.header || {};
          const toARGB = (hex) => {
            const clean = String(hex || '').trim().replace('#','').toUpperCase();
            if (!clean) return '';
            return (clean.length === 6 ? ('FF' + clean) : clean);
          };
          const fillHex = toARGB(headerCfg.fillColor);
          const fontHex = toARGB(headerCfg.fontColor);
          const makeStyle = () => {
            const s = {};
            if (fillHex) s.fill = { patternType: "solid", fgColor: { rgb: fillHex } };
            if (fontHex || headerCfg.bold) s.font = {};
            if (fontHex) s.font.color = { rgb: fontHex };
            if (headerCfg.bold) s.font.bold = true;
            return s;
          };
          documentProcessing = function(workbook){
            try {
              const wsName = sheetName || workbook.SheetNames?.[0];
              const ws = workbook.Sheets?.[wsName];
              if (!ws) return workbook;
              const cols = table.getColumns(true);
              const style = makeStyle();
              for (let i = 0; i < cols.length; i++){
                const addr = XLSX.utils.encode_cell({ c: i, r: 0 });
                const cell = ws[addr];
                if (cell) {
                  cell.s = Object.assign({}, cell.s || {}, style);
                }
              }
            } catch (e) {
              console.warn('XLSX header styling skipped:', e);
            }
            return workbook;
          };
        }

        const extra = (xlsxCfg.options && typeof xlsxCfg.options === 'object') ? xlsxCfg.options : {};
        const dlOptions = Object.assign({ sheetName }, extra, documentProcessing ? { documentProcessing } : {});
        table.download("xlsx", filename, dlOptions);
      } catch (e) {
        console.error("XLSX download failed", e);
        alert("Unable to generate Excel file. Please try again.");
      }
    });

    // 5) Download to PDF using Tabulator + jsPDF + AutoTable, configured per block
    const dlPdfBtn = document.getElementById("download-pdf-{{ block_name }}-{{ instance_id }}");
    dlPdfBtn?.addEventListener("click", function(){
      try {
        const pdfCfg = {{ pdf_download|default:"{}"|safe }} || {};
        const filename = (pdfCfg.filename && String(pdfCfg.filename).trim()) || ("{{ block_name }}" + ".pdf");
        const orientation = pdfCfg.orientation || "portrait";
        const title = (pdfCfg.title && String(pdfCfg.title)) || ("{{ block_title|escapejs }}");
        const extra = (pdfCfg.options && typeof pdfCfg.options === 'object') ? pdfCfg.options : {};

        const toRGB = (hex) => {
          const clean = String(hex || '').trim().replace('#','');
          if (!clean) return undefined;
          const n = parseInt(clean, 16);
          if (clean.length === 3){
            const r = (n >> 8) & 0xF; const g = (n >> 4) & 0xF; const b = n & 0xF;
            return [r*17, g*17, b*17];
          }
          const r = (n >> 16) & 0xFF; const g = (n >> 8) & 0xFF; const b = n & 0xFF;
          return [r, g, b];
        };

        // Build autoTable config to style header
        let autoTableOption;
        const headerCfg = pdfCfg.header || {};
        const headStyles = {};
        const fill = toRGB(headerCfg.fillColor);
        const text = toRGB(headerCfg.fontColor);
        if (fill) headStyles.fillColor = fill;
        if (text) headStyles.textColor = text;
        if (headerCfg.bold) headStyles.fontStyle = 'bold';
        autoTableOption = function(doc){
          return Object.assign({
            headStyles,
            styles: { cellPadding: 3, fontSize: 8 },
            margin: { top: 40 },
            didDrawPage: function(data){
              try {
                if (title && doc && typeof doc.text === 'function'){
                  doc.setFontSize(10);
                  doc.text(String(title), data.settings.margin.left, 24);
                }
              } catch (e) {}
            }
          }, (extra.autoTable || {}));
        };

        const pdfOptions = Object.assign({
          orientation,
          title,
          autoTable: autoTableOption,
        }, extra);

        table.download("pdf", filename, pdfOptions);
      } catch (e) {
        console.error("PDF download failed", e);
        alert("Unable to generate PDF file. Please try again.");
      }
    });
  })();
</script>
{% endblock %}

</div>
