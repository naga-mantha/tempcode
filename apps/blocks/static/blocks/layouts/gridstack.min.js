(function (global) {
  class GridStackMock {
    constructor(element, opts) {
      this.el = element;
      this.opts = opts || {};
      this._dragged = null;
      this._handlers = new Map();
      this.refresh();
    }

    static init(opts, element) {
      if (!element) {
        throw new Error('GridStack requires a root element');
      }
      if (element._gridstackInstance) {
        element._gridstackInstance.refresh();
        return element._gridstackInstance;
      }
      const instance = new GridStackMock(element, opts || {});
      element._gridstackInstance = instance;
      return instance;
    }

    on(eventName, callback) {
      if (!this._handlers.has(eventName)) {
        this._handlers.set(eventName, []);
      }
      this._handlers.get(eventName).push(callback);
    }

    refresh() {
      const margin = parseInt(
        this.opts.margin ?? this.el.dataset.gridGap ?? '15',
        10
      );
      if (!Number.isNaN(margin)) {
        this.el.style.setProperty('--grid-gap', margin + 'px');
      }
      const columns = parseInt(
        this.opts.column ??
          this.opts.columns ??
          this.el.dataset.gridColumns ??
          '12',
        10
      );
      if (!Number.isNaN(columns) && columns > 0) {
        this.el.style.setProperty('--grid-columns', String(columns));
      }
      const rowHeight = parseInt(
        this.opts.rowHeight ?? this.el.dataset.gridRowHeight ?? '200',
        10
      );
      if (!Number.isNaN(rowHeight) && rowHeight > 0) {
        this.el.style.setProperty('--grid-row-height', rowHeight + 'px');
      }
      const items = Array.from(this.el.querySelectorAll('.grid-stack-item'));
      items.forEach((item, index) => this._decorateItem(item, index));
      this._syncPositions({ preserveExisting: true });
    }

    _decorateItem(item, index) {
      if (item.dataset.gridstackBound === '1') {
        this._applyGridStyles(item);
        return;
      }
      item.dataset.gridstackBound = '1';
      if (!item.dataset.gsX) {
        item.dataset.gsX = String(item.dataset.x || 0);
      }
      if (!item.dataset.gsY) {
        item.dataset.gsY = String(index);
      }
      if (!item.dataset.gsWidth) {
        item.dataset.gsWidth = String(
          this.el.dataset.defaultWidth || 4
        );
      }
      if (!item.dataset.gsHeight) {
        item.dataset.gsHeight = String(
          this.el.dataset.defaultHeight || 3
        );
      }
      item.draggable = true;
      this._applyGridStyles(item);

      item.addEventListener('dragstart', (event) => {
        this._dragged = item;
        item.classList.add('is-dragging');
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = 'move';
        }
      });

      item.addEventListener('dragover', (event) => {
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
      });

      item.addEventListener('drop', (event) => {
        event.preventDefault();
        if (!this._dragged || this._dragged === item) {
          return;
        }
        const children = Array.from(
          this.el.querySelectorAll('.grid-stack-item')
        );
        const draggedIndex = children.indexOf(this._dragged);
        const targetIndex = children.indexOf(item);
        if (draggedIndex < targetIndex) {
          item.after(this._dragged);
        } else {
          item.before(this._dragged);
        }
        this._syncPositions();
        this._emit('change', [this._nodeFromEl(this._dragged)]);
        this._dragged = null;
      });

      item.addEventListener('dragend', () => {
        item.classList.remove('is-dragging');
        this._dragged = null;
      });

      item.addEventListener('layout:resize', (event) => {
        const detail = event.detail || {};
        if (typeof detail.width === 'number') {
          item.dataset.gsWidth = String(Math.round(detail.width));
        }
        if (typeof detail.height === 'number') {
          item.dataset.gsHeight = String(Math.round(detail.height));
        }
        this._applyGridStyles(item);
        if (detail.commit) {
          const node = this._nodeFromEl(item);
          this._emit('change', [node]);
          this._emit('resizestop', [node]);
        }
      });
    }

    _columnCount() {
      const raw =
        this.el.style.getPropertyValue('--grid-columns') ||
        this.opts.column ||
        this.opts.columns ||
        this.el.dataset.gridColumns ||
        '12';
      const parsed = parseInt(String(raw).trim(), 10);
      return Number.isNaN(parsed) || parsed <= 0 ? 12 : parsed;
    }

    _applyGridStyles(item) {
      const columns = this._columnCount();
      let width = parseInt(item.dataset.gsWidth || '1', 10);
      if (!Number.isFinite(width) || width < 1) {
        width = 1;
      }
      width = Math.min(width, columns);
      item.dataset.gsWidth = String(width);

      let height = parseInt(item.dataset.gsHeight || '1', 10);
      if (!Number.isFinite(height) || height < 1) {
        height = 1;
      }
      item.dataset.gsHeight = String(height);

      let x = parseInt(item.dataset.gsX || '0', 10);
      if (!Number.isFinite(x) || x < 0) {
        x = 0;
      }
      if (x + width > columns) {
        x = Math.max(0, columns - width);
        item.dataset.gsX = String(x);
      }

      let y = parseInt(item.dataset.gsY || '0', 10);
      if (!Number.isFinite(y) || y < 0) {
        y = 0;
        item.dataset.gsY = '0';
      }

      const columnStart = x + 1;
      const rowStart = y + 1;
      item.style.gridColumn = `${columnStart} / span ${width}`;
      item.style.gridRow = `${rowStart} / span ${height}`;
    }

    _syncPositions({ preserveExisting = false } = {}) {
      const items = Array.from(this.el.querySelectorAll('.grid-stack-item'));
      let currentRow = 0;
      items.forEach((item, index) => {
        const existingY = parseInt(item.dataset.gsY || '', 10);
        const hasExisting =
          preserveExisting && !Number.isNaN(existingY) && existingY >= 0;
        let height = parseInt(item.dataset.gsHeight || '1', 10);
        if (!Number.isFinite(height) || height < 1) {
          height = 1;
          item.dataset.gsHeight = '1';
        }
        const nextRow = hasExisting ? existingY : currentRow;
        item.dataset.gsY = String(nextRow);
        item.dataset.order = String(index);
        this._applyGridStyles(item);
        currentRow = Math.max(currentRow, nextRow + height);
      });
    }

    _nodeFromEl(el) {
      return {
        el,
        x: parseInt(el.dataset.gsX || '0', 10) || 0,
        y: parseInt(el.dataset.gsY || '0', 10) || 0,
        width: parseInt(el.dataset.gsWidth || '1', 10) || 1,
        height: parseInt(el.dataset.gsHeight || '1', 10) || 1,
        id: el.dataset.slug || '',
      };
    }

    _emit(eventName, nodes) {
      const handlers = this._handlers.get(eventName) || [];
      handlers.forEach((handler) => {
        try {
          handler({ type: eventName, target: this.el }, nodes || []);
        } catch (err) {
          if (global.console && console.error) {
            console.error(err);
          }
        }
      });
    }
  }

  global.GridStack = {
    init(opts, element) {
      return GridStackMock.init(opts, element);
    },
  };
})(window);
