(function (global) {
  class GridStackMock {
    constructor(element, opts) {
      this.el = element;
      this.opts = opts || {};
      this._dragged = null;
      this._handlers = new Map();
      this.refresh();
    }

    static init(opts, element) {
      if (!element) {
        throw new Error('GridStack requires a root element');
      }
      if (element._gridstackInstance) {
        element._gridstackInstance.refresh();
        return element._gridstackInstance;
      }
      const instance = new GridStackMock(element, opts || {});
      element._gridstackInstance = instance;
      return instance;
    }

    on(eventName, callback) {
      if (!this._handlers.has(eventName)) {
        this._handlers.set(eventName, []);
      }
      this._handlers.get(eventName).push(callback);
    }

    refresh() {
      const margin = parseInt(
        this.opts.margin ?? this.el.dataset.gridGap ?? '15',
        10
      );
      if (!Number.isNaN(margin)) {
        this.el.style.setProperty('--grid-gap', margin + 'px');
      }
      const items = Array.from(this.el.querySelectorAll('.grid-stack-item'));
      items.forEach((item, index) => this._decorateItem(item, index));
      this._syncPositions();
    }

    _decorateItem(item, index) {
      if (item.dataset.gridstackBound === '1') {
        return;
      }
      item.dataset.gridstackBound = '1';
      if (!item.dataset.gsX) {
        item.dataset.gsX = String(item.dataset.x || 0);
      }
      if (!item.dataset.gsY) {
        item.dataset.gsY = String(index);
      }
      if (!item.dataset.gsWidth) {
        item.dataset.gsWidth = String(
          this.el.dataset.defaultWidth || 4
        );
      }
      if (!item.dataset.gsHeight) {
        item.dataset.gsHeight = String(
          this.el.dataset.defaultHeight || 3
        );
      }
      item.draggable = true;

      item.addEventListener('dragstart', (event) => {
        this._dragged = item;
        item.classList.add('is-dragging');
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = 'move';
        }
      });

      item.addEventListener('dragover', (event) => {
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
      });

      item.addEventListener('drop', (event) => {
        event.preventDefault();
        if (!this._dragged || this._dragged === item) {
          return;
        }
        const children = Array.from(
          this.el.querySelectorAll('.grid-stack-item')
        );
        const draggedIndex = children.indexOf(this._dragged);
        const targetIndex = children.indexOf(item);
        if (draggedIndex < targetIndex) {
          item.after(this._dragged);
        } else {
          item.before(this._dragged);
        }
        this._syncPositions();
        this._emit('change', [this._nodeFromEl(this._dragged)]);
        this._dragged = null;
      });

      item.addEventListener('dragend', () => {
        item.classList.remove('is-dragging');
        this._dragged = null;
      });

      item.addEventListener('layout:resize', (event) => {
        const detail = event.detail || {};
        if (typeof detail.width === 'number') {
          item.dataset.gsWidth = String(detail.width);
        }
        if (typeof detail.height === 'number') {
          item.dataset.gsHeight = String(detail.height);
        }
        this._emit('change', [this._nodeFromEl(item)]);
        this._emit('resizestop', [this._nodeFromEl(item)]);
      });
    }

    _syncPositions() {
      const items = Array.from(this.el.querySelectorAll('.grid-stack-item'));
      items.forEach((item, index) => {
        item.dataset.gsY = String(index);
        item.dataset.order = String(index);
      });
    }

    _nodeFromEl(el) {
      return {
        el,
        x: parseInt(el.dataset.gsX || '0', 10) || 0,
        y: parseInt(el.dataset.gsY || '0', 10) || 0,
        width: parseInt(el.dataset.gsWidth || '1', 10) || 1,
        height: parseInt(el.dataset.gsHeight || '1', 10) || 1,
        id: el.dataset.slug || '',
      };
    }

    _emit(eventName, nodes) {
      const handlers = this._handlers.get(eventName) || [];
      handlers.forEach((handler) => {
        try {
          handler({ type: eventName, target: this.el }, nodes || []);
        } catch (err) {
          if (global.console && console.error) {
            console.error(err);
          }
        }
      });
    }
  }

  global.GridStack = {
    init(opts, element) {
      return GridStackMock.init(opts, element);
    },
  };
})(window);
