from django.core.management.base import BaseCommand
from apps.common.models import Roadmap


# Helper constants
Q1 = Roadmap.Timeframe.Q1
Q2 = Roadmap.Timeframe.Q2
Q3 = Roadmap.Timeframe.Q3
Q4 = Roadmap.Timeframe.Q4

A = Roadmap.App
S = Roadmap.Status


ITEMS = [
    # Layouts (0110, 10/11/12 2025, 02/03 2026)
    dict(app=A.LAYOUTS, timeframe=Q1, title="Arrange blocks into pages; set sizes and positions",
         description="Arrange blocks on a page with set sizes and positions.",
         technical_specifications="Layouts and LayoutBlock with grid positions and per-instance settings; render via block partials."),
    dict(app=A.LAYOUTS, timeframe=Q1, title="Set default settings for blocks on a page",
         description="Set default settings for each block on a page.",
         technical_specifications="Persist defaults in LayoutBlock.settings (JSON); edit via modal; applied at render."),
    dict(app=A.LAYOUTS, timeframe=Q4, title="Page building blocks (text, buttons, cards, spacers)",
         description="Add text, buttons, cards, and spacers to pages.",
         technical_specifications="Content blocks using BlockSpec kind=content; simple settings; template-first with Bootstrap."),
    dict(app=A.LAYOUTS, timeframe=Q4, title="Slide-in filters that remember choices",
         description="Filters open from the side and remember choices.",
         technical_specifications="Offcanvas filter UI; saved FilterConfigs; FilterResolver schema + token support (today, month, year)."),
    dict(app=A.LAYOUTS, timeframe=Q4, title="Consistent headers and actions across pages",
         description="Consistent headers and actions across pages.",
         technical_specifications="Shared chrome header partial (title, saved-configs, export buttons) reused by blocks."),
    dict(app=A.LAYOUTS, timeframe=Q4, title="Load page sections only when needed for speed",
         description="Load sections on demand for faster pages.",
         technical_specifications="Lazy HTMX loads per block; endpoints return partials; skeleton/empty/error states standardized."),
    dict(app=A.LAYOUTS, timeframe=Q4, title="Shared page filters (one date range for all blocks)",
         description="One date range updates all blocks on a page.",
         technical_specifications="Global context bar values injected into each block's FilterResolver; namespaced params."),
    dict(app=A.LAYOUTS, timeframe=Q4, title="Duplicate a page and customize your own copy",
         description="Duplicate a page and customize your own copy.",
         technical_specifications="Copy Layout and child LayoutBlocks; rebind ownership; prune invalid configs; idempotent naming."),
    dict(app=A.LAYOUTS, timeframe=Q4, title="Share a page by copying it to teammates",
         description="Share a page by copying it to teammates.",
         technical_specifications="Share-by-copy endpoint; permission checks; copy visibility and saved configs to recipients."),
    dict(app=A.LAYOUTS, timeframe=Q4, title="Download an entire page as a print-friendly file",
         description="Download an entire page as a print-friendly file.",
         technical_specifications="HTML-to-PDF export (WeasyPrint); layout-aware rendering; honors visibility and filters."),
    dict(app=A.LAYOUTS, timeframe=Q1, title="Finish moving key pages to the new layouts",
         description="Move the most-used pages to the new layouts.",
         technical_specifications="Map V1 routes to V2 equivalents; seed configs; track cutover by feature flags."),
    dict(app=A.LAYOUTS, timeframe=Q1, title="Complete the switch from old layouts to new ones",
         description="Complete the switch to new layouts.",
         technical_specifications="Flip feature flags; remove legacy pages after sign-off; update links and bookmarks."),

    # Table Block (0110, Q4 2025, Q1 2026)
    dict(app=A.TABLE, timeframe=Q1, title="Save column setups just for you or for everyone",
         description="Save and reuse column setups (private/public).",
         technical_specifications="BlockColumnConfig model with visibility; apply/rename/delete; merge with allowed column catalog."),
    dict(app=A.TABLE, timeframe=Q1, title="Save your favorite filters",
         description="Save your favorite filter sets.",
         technical_specifications="BlockFilterConfig saved per user or public; FilterResolver.clean validation; token support."),
    dict(app=A.TABLE, timeframe=Q1, title="Filter panel with the common fields",
         description="Filter panel with common fields.",
         technical_specifications="Template-driven filter form; dependent choices endpoint; reset/apply actions; Tom Select widgets."),
    dict(app=A.TABLE, timeframe=Q1, title="Download to a spreadsheet",
         description="Download table data to a spreadsheet.",
         technical_specifications="CSV/XLSX server export honoring filters, view ordering, and policy; small sets inline."),
    dict(app=A.TABLE, timeframe=Q4, title="Faster loading, smoother sorting, better page controls",
         description="Faster loading, smoother sorting, better page controls.",
         technical_specifications="Remote pagination/sort; select_related/prefetch; stable secondary sort; Tabulator options allowlist."),
    dict(app=A.TABLE, timeframe=Q4, title="Clear messages for empty results and errors",
         description="Clear messages for empty results and errors.",
         technical_specifications="Standardized empty/error states; 4xx handling with toasts; retry hooks on endpoints."),
    dict(app=A.TABLE, timeframe=Q4, title="Polish downloads and add print-friendly files",
         description="Better downloads and print-friendly files.",
         technical_specifications="Consistent CSV/XLSX headers; optional PDF export with audit metadata (who/when/row_count)."),
    dict(app=A.TABLE, timeframe=Q4, title="Click a row to see details",
         description="Click a row to open details.",
         technical_specifications="Drilldown contract: row->detail view mapping with namespaced params; modal or navigate."),
    dict(app=A.TABLE, timeframe=Q4, title="Table: Works with shared page filters",
         description="Table respects shared page filters.",
         technical_specifications="Inject global params into FilterResolver; merge precedence GET > saved > defaults."),
    dict(app=A.TABLE, timeframe=Q1, title="Update simple fields directly on the page",
         description="Update simple fields in place.",
         technical_specifications="Inline edit endpoints with CSRF; PolicyService checks; optimistic UI refresh via events."),
    dict(app=A.TABLE, timeframe=Q1, title="Quick add/edit in a pop-up with auto refresh",
         description="Quick add/edit in a pop-up with auto refresh.",
         technical_specifications="Form modal posts; emits form:saved; table listens to refresh itself; decoupled via events."),
    dict(app=A.TABLE, timeframe=Q4, title="Large downloads run in the background",
         description="Large downloads run in the background with a link when ready.",
         technical_specifications="Queued export jobs (Celery/RQ); job id returned; UI polls and shows link on completion."),

    # Pivot Block
    dict(app=A.PIVOT, timeframe=Q1, title="Pivot views available for key data",
         description="Pivot views available for key data.",
         technical_specifications="Existing V1 pivot endpoints; basic aggregations; template rendering."),
    dict(app=A.PIVOT, timeframe=Q1, title="Save pivot setups (just for you or for everyone)",
         description="Save pivot setups (private/public).",
         technical_specifications="Saved PivotConfig with visibility; select/apply from header; manage defaults."),
    dict(app=A.PIVOT, timeframe=Q4, title="First version with a clean, modern feel",
         description="First modernized pivot experience.",
         technical_specifications="BlockSpec services for data and serializer; shared chrome; consistent filters and exports."),
    dict(app=A.PIVOT, timeframe=Q4, title="Click to see details from a cell",
         description="Click a cell to see details.",
         technical_specifications="Drilldown from aggregated cell to table slice using mapped filters."),
    dict(app=A.PIVOT, timeframe=Q4, title="Pivot: Works with shared page filters",
         description="Pivot respects shared page filters.",
         technical_specifications="Global params merged into FilterResolver before aggregation."),
    dict(app=A.PIVOT, timeframe=Q4, title="Easy totals at the bottom and side",
         description="Easy totals at the bottom and side.",
         technical_specifications="Row/column totals computed in serializer; displayed in template footer/edge."),
    dict(app=A.PIVOT, timeframe=Q4, title="Save favorite setups and switch quickly",
         description="Save favorite pivot setups and switch quickly.",
         technical_specifications="Public/private configs; quick dropdown; make default; rename/duplicate/delete."),
    dict(app=A.PIVOT, timeframe=Q4, title="Download results to a spreadsheet",
         description="Download pivot results to a spreadsheet.",
         technical_specifications="CSV/XLSX export of flattened pivot data; respects filters and drill context."),

    # Pie Block
    dict(app=A.PIE, timeframe=Q4, title="Pie: First version",
         description="First version of the pie chart.",
         technical_specifications="Generic chart block (Pie) fed by serializer; Plotly or Bootstrap-friendly chart lib."),
    dict(app=A.PIE, timeframe=Q4, title="Click a slice to see details",
         description="Click a slice to see details.",
         technical_specifications="Slice drill -> table filter by category; standard drill mapping."),
    dict(app=A.PIE, timeframe=Q4, title="Pie: Works with shared page filters",
         description="Pie respects shared page filters.",
         technical_specifications="Global params merged into chart data query."),
    dict(app=A.PIE, timeframe=Q4, title="Clear labels and legends",
         description="Clear labels and legends.",
         technical_specifications="Formatter for labels/percentages; legend placement; color palette consistency."),
    dict(app=A.PIE, timeframe=Q4, title="Pie: Save favorite chart views",
         description="Save favorite chart views.",
         technical_specifications="Saved ChartConfig per user/public; chart type + settings payload stored as JSON."),
    dict(app=A.PIE, timeframe=Q4, title="Pie: Download the chart or its numbers",
         description="Download the chart or its numbers.",
         technical_specifications="Image download (PNG/SVG) and CSV export of series; respects filters."),

    # Bar Block
    dict(app=A.BAR, timeframe=Q4, title="Bar: First version",
         description="First version of the bar chart.",
         technical_specifications="Generic chart block (Bar) with grouped/stacked support; serializer supplies series."),
    dict(app=A.BAR, timeframe=Q4, title="Click a bar to see details",
         description="Click a bar to see details.",
         technical_specifications="Bar drill -> table slice by category or time bucket."),
    dict(app=A.BAR, timeframe=Q4, title="Bar: Works with shared page filters",
         description="Bar respects shared page filters.",
         technical_specifications="Global params merged into chart data query."),
    dict(app=A.BAR, timeframe=Q4, title="Single or grouped bars with clear labels",
         description="Single or grouped bars with clear labels.",
         technical_specifications="Axis formatters; group keys; legend management; color palette."),
    dict(app=A.BAR, timeframe=Q4, title="Bar: Save favorite chart views",
         description="Save favorite chart views.",
         technical_specifications="Saved ChartConfig (type, x/y/series settings); public/private; default selection."),
    dict(app=A.BAR, timeframe=Q4, title="Bar: Download the chart or its numbers",
         description="Download the chart or its numbers.",
         technical_specifications="Image export and CSV of aggregated series with labels."),

    # Line Block
    dict(app=A.LINE, timeframe=Q4, title="Line: First version",
         description="First version of the line chart.",
         technical_specifications="Generic chart block (Line) with time-aware axes; serializer aggregates by period."),
    dict(app=A.LINE, timeframe=Q4, title="Click a point to see details",
        description="Click a point to see details.",
        technical_specifications="Point drill -> table slice by time bucket and category."),
    dict(app=A.LINE, timeframe=Q4, title="Line: Works with shared page filters",
        description="Line respects shared page filters.",
        technical_specifications="Global params merged into chart data query."),
    dict(app=A.LINE, timeframe=Q4, title="Smooth lines with clear labels",
        description="Smooth lines with clear labels.",
        technical_specifications="Axis formatters, series smoothing, legend controls, color palette."),
    dict(app=A.LINE, timeframe=Q4, title="Line: Save favorite chart views",
        description="Save favorite chart views.",
        technical_specifications="Saved ChartConfig per user/public; default selection and manage actions."),
    dict(app=A.LINE, timeframe=Q4, title="Line: Download the chart or its numbers",
        description="Download the chart or its numbers.",
        technical_specifications="Image export and CSV of series (time, value, category)."),

    # Kanban Block
    dict(app=A.KANBAN, timeframe=Q1, title="First version to track work by stage",
         description="First Kanban to track work by stage.",
         technical_specifications="Kanban lanes by status field; read/write endpoints; basic filters."),
    dict(app=A.KANBAN, timeframe=Q1, title="See items grouped by stage with counts",
         description="See items grouped by stage with counts.",
         technical_specifications="Server aggregation per lane; badge counts; lazy lane loading for large sets."),
    dict(app=A.KANBAN, timeframe=Q1, title="Add new items and update their stage",
         description="Add new items and update their stage.",
         technical_specifications="Form modal to create; drag-and-drop stage change endpoint with PolicyService checks."),
    dict(app=A.KANBAN, timeframe=Q1, title="Move items between stages; basic filters",
         description="Move items between stages; basic filters.",
         technical_specifications="DnD with persistence; filter by owner/date/category; event refresh."),

    # Gantt Block (App key is GANNT)
    dict(app=A.GANNT, timeframe=Q1, title="First version to view timelines across dates",
         description="First Gantt to view timelines across dates.",
         technical_specifications="Plotly px.timeline with start/end; server serializer flattens tasks; read-only v1."),
    dict(app=A.GANNT, timeframe=Q1, title="See tasks by start and end dates",
         description="See tasks by start and end dates.",
         technical_specifications="Serializer emits id,name,start,end,group,color; filtered by date window tokens."),
    dict(app=A.GANNT, timeframe=Q1, title="Basic zoom and scroll on the timeline",
         description="Basic zoom and scroll on the timeline.",
         technical_specifications="Client zoom/pan; server accepts window params; sensible defaults."),
    dict(app=A.GANNT, timeframe=Q1, title="Show details when you select a task",
         description="Show details when you select a task.",
         technical_specifications="Click event opens detail modal/table slice via drill mapping."),
    dict(app=A.GANNT, timeframe=Q1, title="Better grouping and navigation on the timeline",
         description="Better grouping and navigation on the timeline.",
         technical_specifications="Group by owner/project; quick jump to today/this week; cached slices."),

    # Repeater Block
    dict(app=A.REPEATER, timeframe=Q1, title="Simple list views available today",
         description="Simple list views available today.",
         technical_specifications="Existing repeater templates and endpoints; lightweight filters."),
    dict(app=A.REPEATER, timeframe=Q1, title="Polish and quality improvements",
         description="Polish and quality improvements.",
         technical_specifications="Consistent chrome; empty/error states; minor performance tweaks."),

    # Workflows
    dict(app=A.WORKFLOWS, timeframe=Q1, title="Standard approval steps where needed",
         description="Standard approval steps where needed.",
         technical_specifications="Existing workflow checks; staged rollout to PolicyService facade."),
    dict(app=A.WORKFLOWS, timeframe=Q1, title="Basic rules for who can act",
         description="Basic rules for who can act.",
         technical_specifications="Baseline role checks; audit key transitions; generous defaults."),
    dict(app=A.WORKFLOWS, timeframe=Q4, title="Basic, generous controls to keep work moving",
         description="Basic, generous controls to keep work moving.",
         technical_specifications="PolicyService facade returns permissive results; logs access for later hardening."),
    dict(app=A.WORKFLOWS, timeframe=Q1, title="Clear messages when actions are not allowed",
         description="Clear messages when actions are not allowed.",
         technical_specifications="Uniform error messaging from policy/permission checks; inline toasts and disabled states."),
    dict(app=A.WORKFLOWS, timeframe=Q1, title="Stronger rules for when items can move forward",
         description="Stronger rules for when items can move forward.",
         technical_specifications="Integrate real permission/workflow rules behind PolicyService; add caching where safe."),
    dict(app=A.WORKFLOWS, timeframe=Q1, title="History of important changes",
         description="History of important changes.",
         technical_specifications="Audit log of key transitions with who/when/what; surfaced in UI."),

    # Permissions
    dict(app=A.PERMISSIONS, timeframe=Q1, title="Standard rules for who can see and edit",
         description="Standard rules for who can see and edit.",
         technical_specifications="Existing permission checks for read/write at field and object level."),
    dict(app=A.PERMISSIONS, timeframe=Q4, title="One simple place for access rules",
         description="One simple place for access rules.",
         technical_specifications="PolicyService facade: filter_queryset, can_read_field, can_write_field used across blocks."),
    dict(app=A.PERMISSIONS, timeframe=Q1, title="Stricter controls with minimal friction",
         description="Stricter controls with minimal friction.",
         technical_specifications="Rollout flags: shadow -> enforce; test coverage for block data masking and scoping."),
    dict(app=A.PERMISSIONS, timeframe=Q4, title="Team-level visibility for shared views and pages",
         description="Team-level visibility for shared views and pages.",
         technical_specifications="Visibility scopes beyond public/private for configs and layouts; team membership checks."),
    dict(app=A.PERMISSIONS, timeframe=Q1, title="History of changes for shared items",
         description="History of changes for shared items.",
         technical_specifications="Audit on share/visibility changes with who/when; admin viewable."),

    # Common
    dict(app=A.COMMON, timeframe=Q1, title="Existing pages and dashboards continue to run",
         description="Existing pages and dashboards continue to run.",
         technical_specifications="Legacy pages kept during migration; V1/V2 coexist behind flags."),
    dict(app=A.COMMON, timeframe=Q4, title="Light and dark themes",
         description="Light and dark themes.",
         technical_specifications="Bootstrap 5.3 color modes via data-bs-theme; persist in localStorage + cookie."),
    dict(app=A.COMMON, timeframe=Q4, title="Tags and search for saved views",
         description="Tags and search for saved views.",
         technical_specifications="Config tags + search across manage pages; discoverability improvements."),
    dict(app=A.COMMON, timeframe=Q4, title="Background work for heavy tasks with a link when ready",
         description="Background work for heavy tasks with a link when ready.",
         technical_specifications="Queued jobs for exports/heavy ops; UI polls and shows completion link."),
    dict(app=A.COMMON, timeframe=Q1, title="Show selected tables and charts inside other tools, safely",
         description="Show selected tables and charts inside other tools, safely.",
         technical_specifications="Signed/tokenized embedding URLs; whitelist params; CSP guidance for third-party sites."),
    dict(app=A.COMMON, timeframe=Q1, title="Admin page to watch speed and fix slow screens",
         description="Admin page to watch speed and fix slow screens.",
         technical_specifications="Telemetry for render times and row counts; admin dashboard for slowest blocks."),
    dict(app=A.COMMON, timeframe=Q1, title="Move key pages to the new experience",
         description="Move key pages to the new experience.",
         technical_specifications="Staged cutover with flags; migrate saved configs; parity checks before flip."),
    dict(app=A.COMMON, timeframe=Q1, title="Finish the switch and clean up older pages",
         description="Finish the switch and clean up older pages.",
         technical_specifications="Remove legacy code after approval; redirect old URLs; finalize docs."),
    dict(app=A.COMMON, timeframe=Q1, title="Tips, guides, and training",
         description="Tips, guides, and training.",
         technical_specifications="Add inline help, quickstart docs, and short videos for common tasks."),
]


class Command(BaseCommand):
    help = "Create or update Roadmap entries from curated seed data"

    def handle(self, *args, **options):
        created = 0
        updated = 0
        for data in ITEMS:
            obj, was_created = Roadmap.objects.update_or_create(
                title=data["title"],
                defaults=dict(
                    description=data["description"],
                    technical_specifications=data["technical_specifications"],
                    status=S.PLANNED,
                    timeframe=data["timeframe"],
                    app=data["app"],
                ),
            )
            if was_created:
                created += 1
            else:
                updated += 1
        self.stdout.write(self.style.SUCCESS(f"Seed complete. Created: {created}, Updated: {updated}"))
