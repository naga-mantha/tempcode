# Apps V2 Documentation

## 1. Scope and Goals
- Apps V2 provides the decomposition for the ongoing rewrite: spec-driven blocks, a thin layout layer, and a policy facade that coexist with legacy v1 views.
- The code lives under `apps_v2/` and currently focuses on delivering table blocks with saved configurations, filter layouts, and export plumbing.
- Everything is designed to be additive: V1 pages keep working while V2 blocks are introduced via dedicated URLs.

## 2. Directory Structure
- `apps_v2/__init__.py` - namespace marker with high-level intent.
- `apps_v2/blocks/` - block registry, controller, shared services, HTTP endpoints, and shipped table specs.
- `apps_v2/layout/` - placeholder URL set (health check for future layout features).
- `apps_v2/policy/` - permissive `PolicyService` facade that V2 components depend on.

## 3. Block Architecture

### 3.1 BlockSpec and Services (`apps_v2/blocks/specs.py`)
- `BlockSpec` is the declarative contract for every block. Key fields:
  - `id`: globally unique code (also used as the Block model `code`).
  - `kind`: `table`, `pivot`, `chart`, or `content` (validated in the registry).
  - `template`: Django template rendered for the block shell.
  - `supported_features`: list of feature flags (filters, column_config, export, inline_edit, drilldown).
  - `services`: typed refs (`filter_resolver`, `column_resolver`, `query_builder`, `serializer`, `export_options`).
  - Optional helpers: `table_options`, `model`, `filter_schema`, `column_max_depth`, `download_options`.
- `Services` is a thin dataclass holding references to the runtime service classes.

### 3.2 Registry and Spec Loading (`apps_v2/blocks/registry.py`, `apps_v2/blocks/register.py`)
- `register(spec)` validates the spec (kind, template presence, supported features, Tabulator option allowlist) and stores it in a process-wide registry.
- For table specs we enforce that `column_resolver`, `query_builder`, and `serializer` are provided; if `Model*` helpers are used, the spec must declare a Django model.
- `load_specs()` in `register.py` lazily registers:
  - `v2.hello` demo content block.
  - `v2.layouts.table` and `v2.items.table` specs from `apps_v2.blocks.tables`.
- `get_registry()` returns a copy of the registered specs for callers that need iteration without mutating the global state.

### 3.3 Service Interfaces (`apps_v2/blocks/services/base.py`)
- `FilterResolver`: turns a `request` into a safe filter dictionary (optionally also exposes `.clean(values)` and `.schema()`).
- `QueryBuilder`: receives the cleaned filters and returns a queryset for the block.
- `ColumnResolver`: composes the visible column list.
- `Serializer`: converts the queryset into row dicts using the resolved columns (and can consult the policy service per field).
- `ExportOptions`: optional hooks to adjust filenames, sheet names, or mutate columns/rows prior to download.

### 3.4 Model-driven Table Services (`apps_v2/blocks/services/model_table.py`)
- `SchemaFilterResolver` reads `filter_schema` entries from the spec, handles alternate names (`filters.<key>`), parses types, and knows about date tokens such as `__today__`.
- `prune_filter_schema` removes schema elements that the current user cannot read according to the policy layer.
- `prune_filter_values` guards against unknown filter keys and keeps multi-value lists intact.
- `_coerce_value` and `_resolve_date_token` provide typing support across text/number/date/datetime/boolean/multiselect filters.
- `ModelColumnResolver` introspects the declared `model` to build a field catalog (with optional relation depth limits).
- `ModelQueryBuilder` applies per-field lookups derived from the schema and delegates to `PolicyService.filter_queryset`.
- `ModelSerializer` walks dotted paths on model instances when building Tabulator rows, masking fields the policy service disallows.

### 3.5 Export Helpers (`apps_v2/blocks/services/export_options.py`)
- `DefaultExportOptions` is a no-op implementation that callers can override via the spec.
- Hooks provided: `filename`, `sheet_name`, `transform_columns`, `transform_rows`.

### 3.6 Table Options Utilities (`apps_v2/blocks/options.py`)
- `ALLOWED_OPTIONS` is the Tabulator allowlist. Only these keys are merged from spec defaults, saved configs, or request parameters.
- `merge_table_options(*sources)` shallow-merges sources left-to-right while coercing types (`int`, `bool`, `list`, etc.). Invalid entries are dropped silently for robustness.

## 4. Controller Lifecycle (`apps_v2/blocks/controller.py`)
 `BlockController.build_context(request)` orchestrates a full render:
1. Load and resolve services (filter resolver, column resolver) declared on the spec.
2. Gather saved table configs and filter configs via `apps_v2.blocks.configs`.
3. Resolve filter schema (with choices URLs) and prune values using `prune_filter_values`.
4. Read metadata from the request:
   - `filters.__cleared` lists keys the user cleared while keeping a saved filter active.
   - These keys are removed from `base_filter_values` before merging with live overrides.
5. Compose `frontend_config` for the JS bootstrap (`domId`, `filterKeys`, `dataUrl`, Tabulator options, etc.).
6. Fetch initial rows immediately when pagination is local; otherwise rely on Tabulator's remote pagination to hit the JSON endpoint.
7. Return a context dict consumed by `v2/blocks/table/table_card.html` (filters, badges, layout, download URLs, configs, etc.).

This keeps render-time behavior consistent between the first page load and subsequent AJAX refreshes.

## 5. Persistence Helpers (`apps_v2/blocks/configs.py`)
- `get_block_for_spec(spec_id)` ensures there is a `Block` row for the spec (DB-wins philosophy).
- `list_table_configs` / `list_filter_configs` load user-visible presets, ordering private entries before public ones.
- `choose_active_*_config` selects the preferred config using the explicit query string, user defaults, public defaults, and finally the first available entry.

## 6. HTTP Endpoints (`apps_v2/blocks/views.py`, `apps_v2/blocks/urls.py`)
All routes live under the `blocks_v2` namespace.

### 6.1 Core Endpoints
- `GET /blocks/v2/render/<spec_id>` -> `render_spec`: renders the block template and embeds `frontend_config`.
- `GET /blocks/v2/data/<spec_id>` -> `data_spec`: JSON endpoint for Tabulator remote pagination/sorting.
  - Mirrors the controller's filter handling, including `filters.__cleared` pruning.
- `GET /blocks/v2/choices/<spec_id>/<field>` -> `choices_spec`: AJAX choices for select/multiselect filters, respecting current filter values and policy.
- `GET /blocks/v2/export/<spec_id>.<fmt>` -> `export_spec`: CSV/XLSX export (PDF placeholder) with optional `DefaultExportOptions` hooks.

### 6.2 Saved Config Management
- Table configs: `save_table_config`, `rename_table_config`, `duplicate_table_config`, `delete_table_config`, `make_default_table_config`.
- Filter configs: `save_filter_config`, `manage_filters`, `rename_filter_config`, `duplicate_filter_config`, `delete_filter_config`, `make_default_filter_config`.
- Filter layout management: `manage_filter_layout`, `manage_filter_layout_default`, `save_filter_layout`, `save_filter_layout_default` (backs the accordion layout rendered in the table card template).

All mutating endpoints expect authenticated users and return partial HTML that updates the saved-config drawers.

### 6.3 Demo Views
- `GET /blocks/v2/table/layouts` and `/blocks/v2/table/items` render the shipped table specs through `BlockController` for manual testing.
- `GET /blocks/v2/hello` returns a minimal content block (sanity check endpoint).

## 7. Frontend Integration (`apps/common/src/js/v2-table-filters.js`)
Although the script lives outside `apps_v2`, it is tightly coupled to the table block:
- Parses `frontend_config` served by the controller and registers the `domId` + filter keys.
- Builds filter submissions by:
  - Clearing stale params from the URL (`filters.__active`, `filters.__cleared`, and each filter key).
  - Serializing form values and appending `filters.__cleared=<key>` for fields left blank.
- Reuses the same metadata for full page loads, Tabulator AJAX calls, and exports so clearing a field behaves identically everywhere.
- Boots TomSelect instances, manages dependent dropdown refreshes, and wires export/download buttons.

## 8. Table Specs Shipped (`apps_v2/blocks/tables/`)
- `LayoutsTableSpec` (`v2.layouts.table`): uses generic model services pointed at `apps.layout.models.Layout`; schema includes visibility, name, category text filters, multiselect categories, and date range tokens.
- `ItemsTableSpec` (`v2.items.table`): targets `apps.common.models.items.Item`; demonstrates async choice loaders (item codes, groups, types) with `min_query_length` overrides. Includes a commented example of a custom query builder for pre-filtering.
- Both specs set Tabulator options, download defaults, and rely on `DefaultExportOptions` for now.

## 9. Policy Service (`apps_v2/policy/service.py`)
- Phase-1 stub returning permissive results (`filter_queryset` passthrough, `can_read_field`/`can_write_field` always `True`).
- All V2 components call into this facade, so tightening permissions later will not require refactoring controllers or services.

## 10. Layout Module (`apps_v2/layout/urls.py`)
- Currently exposes `GET /layout/v2/ping` for health checks.
- Serves as the placeholder for future layout management endpoints described in the R&D plan.

## 11. Data Flow Summary
1. Spec is registered via `load_specs()` at startup or on demand.
2. A request hits `render_spec` or one of the demo table routes.
3. `BlockController` resolves services, saved configs, filters, and builds context.
4. Template renders with `frontend_config` JSON.
5. Frontend JS bootstraps, handles form submits, and triggers `data_spec` as needed.
6. Saved configs and filter layouts are manipulated via dedicated POST endpoints that update partial HTML.
7. Exports go through `export_spec`, using the same filter-merging logic as renders/JSON.

## 12. Extending Apps V2
To add a new table block:
1. Define a spec module (e.g., `apps_v2.blocks.tables.my_table`) that builds a `BlockSpec` and optional demo view.
2. Provide service implementations (reuse `Model*` helpers or write custom classes).
3. Import the spec in `apps_v2.blocks.register.load_specs()` so it is registered on startup.
4. Add routes or integrate the block into a layout once the layout layer is ready.
5. Update frontend logic only if the filter UI requires custom behavior; otherwise inherit the shared `v2-table-filters.js` flow.

## 13. Current Limitations and Todo Items
- Choice caching: the `choices_spec` endpoint currently hits the database on every request; the roadmap calls for caching payloads short-term.
- Policy enforcement: `PolicyService` is permissive; real permission rules will arrive in later phases.
- Shared block chrome: templates still live in table-specific partials; future work will extract a reusable chrome for pivot/chart blocks.
- Export pipeline: `DefaultExportOptions` exists, but advanced formatting, queued exports, and PDF support remain future work.

## 14. References
- R&D plan: `REWRITE_RnD.md` (Phases B onward describe how these components evolve).
- Frontend filters: `apps/common/src/js/v2-table-filters.js` (compiled copy in `apps/common/static/common/js/`).
- Saved config templates: `apps/common/templates/v2/blocks/table/table_card.html` and `apps/common/templates/v2/blocks/filter/_saved_filters.html`.

## 15. Pivot Blocks
- Pivot specs live under `apps_v2/blocks/pivots/`; the new `ItemsPivotSpec` demonstrates wiring filter resolvers, model query builders, and the shared `DefaultPivotEngine`.
- `BlockController` now understands `kind == "pivot"`, merging saved filter overrides, resolved schemas, and pivot configurations before handing data to the template.
- Saved pivot settings reuse `PivotConfig` with public/private visibility, managed via the V2 settings UI (`/blocks/v2/pivot/manage/<spec_id>`), including duplication, rename, deletion, and default selection.
- Exports (CSV/XLSX) and the JSON endpoint reuse the engine so the rendered grid matches downloaded data.
- Frontend integration leans on the existing filter metadata helpers with a new pivot card template to toggle saved configurations without reloading bespoke JS.
